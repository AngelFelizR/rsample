% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/misc.R
\name{make_splits}
\alias{make_splits}
\alias{make_splits.default}
\alias{make_splits.list}
\alias{make_splits.data.frame}
\title{Constructors for split objects}
\usage{
make_splits(x, ...)

\method{make_splits}{default}(x, ...)

\method{make_splits}{list}(x, data, class = NULL, ...)

\method{make_splits}{data.frame}(x, assessment, ...)
}
\arguments{
\item{x}{A list of integers with names "analysis" and "assessment", or a
data frame of analysis or training data.}

\item{...}{Not currently used.}

\item{data}{A data frame.}

\item{class}{An optional class to give the object.}

\item{assessment}{A data frame of assessment or testing data, which can be empty.}
}
\description{
Constructors for split objects
}
\examples{
# Creating data.frame to sample
df <-
  data.frame(
    year = 1900:1999,
    value = 10 + 8*1900:1999 + runif(100L, 0, 100)
  )


# If our training data goes from 1900 to 1980
# we have 2 ways the rsplit object using make_splits function

# 1. Passing the training and testing data to the function

split_1 <-
  make_splits(x = df[df$year <= 1980,],
              assessment = df[df$year > 1980,])


# 2. Passing the training and testing row indexes in a list

row_index <- seq_len(nrow(df))

split_2 <-
  make_splits(x = list(analysis   = row_index[df$year <= 1980],
                       assessment = row_index[df$year >  1980]),
              data = df)

# In both cases the result is identical
identical(training(split_1)$value, training(split_2)$value)
}
